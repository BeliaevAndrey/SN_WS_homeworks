# 1. Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
# 2. В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно
# дополнительных аргументов. Попробуйте вызвать функцию в следующих ситуациях и объясните результат:
#    - прокинуть в функцию только 1 аргумент
#    - прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
#    - создать кортеж со значениями и распаковать его при вызове функции с помощью *
#    - создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?


# 1. Написать функцию, которая на вход будет принимать произвольное количество аргументов и возвращать их сумму.
def summation_first(*args: [int, float]):
    return sum(args)


print(summation_first(1, 2, 3, 4, 5))
print(summation_first(1.5, 2.5, 3.5, 4.5, 5.5))


# 2. В сигнатуре функции объявить 4 обязательных аргумента, но оставить возможность передавать в неё сколько угодно
# дополнительных аргументов.
def summation_second(a, b, c, d, *args):
    return sum((a, b, c, d)) + sum(args)


#    - прокинуть в функцию только 1 аргумент
try:
    summation_second(1)
except TypeError as exc:
    print(exc.__repr__())
# TypeError("summation_second() missing 3 required positional arguments: 'b', 'c', and 'd'")
# отсутствуют обязательные позиционные аргументы


# - прокинуть аргументы таким образом, чтобы обязательный аргумент был передан одновременно позиционно и по ключу
try:
    summation_second(1, 2, 3, 4, b=4)
except TypeError as exc:
    print(exc.__repr__())
# TypeError("summation_second() got multiple values for argument 'b'")
# функция получила множественные значения для аргумента b


#    - создать кортеж со значениями и распаковать его при вызове функции с помощью *
args_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 0)
print(summation_second(*args_tuple))    # output: 45
# в функцию передается распакованный кортеж: 1, 2, 3, 4, 5, 6
# аргументы 1 -- 4 соответствуют позиционным a, b, c, d
# аргументы 5 -- 0 соответствуют опциональным *args


#    - создать словарь со значениями и распаковать его при вызове функции с помощью * и **: что наблюдаете? Почему?
args_dict = {
    'a': 1,
    'c': 3,
    'b': 2,
    'd': 5,
             }
print(summation_second(**args_dict))    # output: 11
# словарь распаковывается в конструкцию вида: a=1, c=3, b=2, d=4 ,
# таким образом функция получает значения аргументов по ключу.
